#ifndef LEX_H_INCLUDED
#define LEX_H_INCLUDED

/*

* DECLARATION DES CLASSES LEXICALES

*/

typedef enum {
// lexemes de ada 2012

    ABORT_TOKEN, ABS_TOKEN, ABSTRACT_TOKEN,

    ACCEPT_TOKEN, ACCESS_TOKEN, ALIASED_TOKEN,

    ALL_TOKEN, AND_TOKEN, ARRAY_TOKEN, AT_TOKEN,

    BEGIN_TOKEN, BODY_TOKEN, CASE_TOKEN, CONSTANT_TOKEN,

    DECLARE_TOKEN, DELAY_TOKEN, DELTA_TOKEN, DIGITS_TOKEN,

    DO_TOKEN, ELSE_TOKEN, ELSIF_TOKEN, END_TOKEN,

    ENTRY_TOKEN, EXCEPTION_TOKEN, EXIT_TOKEN, FOR_TOKEN,

    FUNCTION_TOKEN, GENERIC_TOKEN, GOTO_TOKEN,

    IF_TOKEN, IN_TOKEN, INTERFACE_TOKEN, IS_TOKEN,

    LIMITED_TOKEN, LOOP_TOKEN, MOD_TOKEN,

    NEW_TOKEN, NOT_TOKEN, NULL_TOKEN, OF_TOKEN,

    OR_TOKEN, OTHERS_TOKEN, OUT_TOKEN, OVERRIDING_TOKEN,

    PACKAGE_TOKEN, PRAGMA_TOKEN, PRIVATE_TOKEN,

    PROCEDURE_TOKEN, PROTECTED_TOKEN,RAISE_TOKEN, RANGE_TOKEN,

    RECORD_TOKEN, REM_TOKEN, RENAMES_TOKEN,

    REQUEUE_TOKEN, RETURN_TOKEN, REVERSE_TOKEN,

    SELECT_TOKEN, SEPARATE_TOKEN, SOME_TOKEN,

    SUBTYPE_TOKEN,

    SYNCHRONIZED_TOKEN, TAGGED_TOKEN,

    TASK_TOKEN, TERMINATE_TOKEN, THEN_TOKEN,

    TYPE_TOKEN, UNTIL_TOKEN, USE_TOKEN,

    WHEN_TOKEN, WHILE_TOKEN, WITH_TOKEN, XOR_TOKEN, LAST_TOKEN, FIRST_TOKEN, 

    /////////////////////////////////////////

    COM_TOKEN, PRINT_TOKEN, READ_TOKEN,



    ID_TOKEN, NUM_TOKEN,ERREUR_TOKEN,

    PV_TOKEN, PT_TOKEN, PLUS_TOKEN, MOINS_TOKEN, MULT_TOKEN,

    DIV_TOKEN, VIR_TOKEN, AFF_TOKEN,EGAL_TOKEN, INF_TOKEN, INFEG_TOKEN,

    SUP_TOKEN, SUPEG_TOKEN, DIFF_TOKEN, PO_TOKEN, PF_TOKEN,EC_TOKEN,

    FIN_TOKEN, DOUBLE_POINT_TOKEN, APP_TOKEN, DOUBLE_QUOTES_TOKEN,AFFEC_MULT_TOKEN,

    AFFEC_DIV_TOKEN,FLOAT_TOKEN,STRING_TOKEN, MULT_AFFEC_TOKEN, DIV_AFFEC_TOKEN, TRUE_TOKEN, FALSE_TOKEN 

    } CODE_LEX ;


CODE_LEX LAST;

typedef struct {

    CODE_LEX CODE;

    char NOM[20];

} Token;



typedef enum{

    FALSE = 0,

    TRUE = 1

} boolean;

extern boolean first;

extern boolean follow_token;

extern Token tabToken[];

extern int nbMotRes;

extern char Car_Cour;

extern Token SYM_COUR;



/*
* GESTION DES ERREURS
*/

typedef enum{
    ERR_CAR_INC,
    ERR_FICH_VID,
    ERR_ID_LONG,
    ERR_ID_INV,
    ERR_NBR_LONG,
    ERR_OP_INC,
    ERR_COM_INC,

    PROGRAM_ERR,
    ID_ERR,
    PV_ERR,
    PT_ERR,
    EGAL_ERR,
    NUM_ERR,
    CONST_VAR_BEGIN_ERR,
    BEGIN_ERR,
    END_ERR,DOUBLE_POINT_ERR, LOOP_ERR, APP_ERR,RECORD_ERR, OF_ERR, DOUBLE_QUOTES_ERR, 
    INST_END_ERR,
    AFF_ERR,
    PO_ERR,
    PF_ERR,
    IF_THEN_ERR,
    OP_COMPAR_ERR,
    FACT_NOT_FOUND_ERR,
    WHILE_DO_ERR,
    WRITE_ERR,
    READ_ERR,
    GENCODE_TAILLE_ERR, FUNC_NAME_ERR, RETURN_ERR,
    IN_ERR,SUP_ERR, IS_ERR, CASE_ERR, THEN_ERR, IF_ERR,
    INST_PCODE_ERR
}Erreurs_t;

typedef struct  {
    Erreurs_t CODE_ERR;
    char mes[40];
} Erreurs;

extern Erreurs MES_ERR[] ;
extern int tailleERR;



//signatures des fonctions utilisees

extern void showCodeToken(Token token);

extern int estBlanc(char c);

int isAccentLettre();

int is_underscore();

void lire_Car();

void lire_mot();

void lire_nombre();

void lire_spcial();

void lire_commentaire(void );

extern void detectError( Erreurs_t er);

extern void nextToken(void);

extern FILE *fl;

extern boolean debugLEX;


#endif // LEX_H_INCLUDED
